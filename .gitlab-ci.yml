# GitLab CI/CD Pipeline for otel-journal-gatewayd-forwarder
#
# Stages:
#   1. lint     - Code formatting and linting
#   2. test     - Unit tests
#   3. e2e      - End-to-end tests (parallel across distros)
#   4. build    - Build release binary
#   5. release  - Upload artifacts to GitLab and GitHub

variables:
  CARGO_HOME: $CI_PROJECT_DIR/.cargo
  RUSTFLAGS: "-D warnings"
  BINARY_NAME: otel-journal-gatewayd-forwarder
  # E2E test settings
  E2E_IMAGE_PREFIX: otel-journal-e2e
  E2E_RESULTS: .e2e-results

stages:
  - lint
  - test
  - e2e
  - build
  - release

# Cache Cargo dependencies between jobs
.rust-cache: &rust-cache
  cache:
    key: ${CI_COMMIT_REF_SLUG}-rust
    paths:
      - .cargo/
      - target/

# Base Rust image
.rust-base: &rust-base
  image: rust:1.87-bookworm
  before_script:
    - rustup component add rustfmt clippy
  <<: *rust-cache

# =============================================================================
# LINT STAGE
# =============================================================================

fmt:
  stage: lint
  <<: *rust-base
  script:
    - cargo fmt --check
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

clippy:
  stage: lint
  <<: *rust-base
  script:
    - cargo clippy --all-targets --all-features -- -D warnings
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

# =============================================================================
# TEST STAGE
# =============================================================================

unit-test:
  stage: test
  <<: *rust-base
  script:
    - cargo test --all-features
  artifacts:
    when: always
    reports:
      junit: target/nextest/ci/junit.xml
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

# =============================================================================
# E2E TESTS (Parallel Matrix)
# =============================================================================

.e2e-base: &e2e-base
  stage: e2e
  image: quay.io/podman/stable:latest
  tags:
    - privileged # Required for running systemd containers
  variables:
    STORAGE_DRIVER: vfs
  before_script:
    - podman info
    - mkdir -p ${E2E_RESULTS}/${DISTRO}
  script:
    - |
      echo "Building e2e container for ${DISTRO}..."
      podman build -f e2e/Containerfile \
        --build-arg DISTRO=${DISTRO} \
        -t ${E2E_IMAGE_PREFIX}-${DISTRO} .
    - |
      echo "Running e2e tests for ${DISTRO}..."
      ./e2e/run-in-container.sh ${E2E_IMAGE_PREFIX}-${DISTRO} ${E2E_RESULTS}/${DISTRO}
  after_script:
    - |
      if [ -f "${E2E_RESULTS}/${DISTRO}/logs.json" ]; then
        echo "Log records captured:"
        jq -s '[.[].resourceLogs[]?.scopeLogs[]?.logRecords[]?] | length' \
          "${E2E_RESULTS}/${DISTRO}/logs.json" || echo "N/A"
      fi
  artifacts:
    when: always
    paths:
      - ${E2E_RESULTS}/${DISTRO}/
    expire_in: 7 days
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

e2e:fedora:
  <<: *e2e-base
  variables:
    DISTRO: fedora

e2e:al2023:
  <<: *e2e-base
  variables:
    DISTRO: al2023

e2e:debian:
  <<: *e2e-base
  variables:
    DISTRO: debian

# =============================================================================
# BUILD STAGE
# =============================================================================

build:release:
  stage: build
  <<: *rust-base
  script:
    - cargo build --release
    - strip target/release/${BINARY_NAME}
    - |
      echo "Binary info:"
      ls -lh target/release/${BINARY_NAME}
      file target/release/${BINARY_NAME}
  artifacts:
    paths:
      - target/release/${BINARY_NAME}
    expire_in: 30 days
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_COMMIT_TAG

# =============================================================================
# RELEASE STAGE
# =============================================================================

# Upload to GitLab Package Registry
upload:gitlab:
  stage: release
  image: curlimages/curl:latest
  dependencies:
    - build:release
  script:
    - |
      VERSION="${CI_COMMIT_TAG:-${CI_COMMIT_SHORT_SHA}}"
      echo "Uploading ${BINARY_NAME} version ${VERSION} to GitLab..."

      curl --header "JOB-TOKEN: ${CI_JOB_TOKEN}" \
           --upload-file "target/release/${BINARY_NAME}" \
           "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/${BINARY_NAME}/${VERSION}/${BINARY_NAME}-linux-amd64"
  rules:
    - if: $CI_COMMIT_TAG
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

# Create GitLab Release (tags only)
release:gitlab:
  stage: release
  image: registry.gitlab.com/gitlab-org/release-cli:latest
  dependencies:
    - build:release
  script:
    - echo "Creating GitLab release for ${CI_COMMIT_TAG}"
  release:
    tag_name: $CI_COMMIT_TAG
    name: "Release $CI_COMMIT_TAG"
    description: |
      ## Release $CI_COMMIT_TAG

      ### Downloads
      - [Linux AMD64](${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/${BINARY_NAME}/${CI_COMMIT_TAG}/${BINARY_NAME}-linux-amd64)

      ### Changelog
      See [CHANGELOG.md](CHANGELOG.md) for details.
    assets:
      links:
        - name: "${BINARY_NAME}-linux-amd64"
          url: "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/${BINARY_NAME}/${CI_COMMIT_TAG}/${BINARY_NAME}-linux-amd64"
          link_type: package
  rules:
    - if: $CI_COMMIT_TAG

# Upload to GitHub Releases
# Requires: GITHUB_TOKEN variable with repo permissions
# Set in GitLab CI/CD Settings > Variables
upload:github:
  stage: release
  image: alpine:latest
  dependencies:
    - build:release
  before_script:
    - apk add --no-cache curl jq
  script:
    - |
      if [ -z "${GITHUB_TOKEN:-}" ]; then
        echo "GITHUB_TOKEN not set, skipping GitHub release"
        exit 0
      fi

      if [ -z "${GITHUB_REPO:-}" ]; then
        echo "GITHUB_REPO not set (e.g., 'owner/repo'), skipping GitHub release"
        exit 0
      fi

      VERSION="${CI_COMMIT_TAG}"
      if [ -z "${VERSION}" ]; then
        echo "Not a tag pipeline, skipping GitHub release"
        exit 0
      fi

      echo "Creating GitHub release ${VERSION}..."

      # Create release
      RELEASE_RESPONSE=$(curl -s -X POST \
        -H "Authorization: token ${GITHUB_TOKEN}" \
        -H "Accept: application/vnd.github.v3+json" \
        "https://api.github.com/repos/${GITHUB_REPO}/releases" \
        -d "{
          \"tag_name\": \"${VERSION}\",
          \"name\": \"Release ${VERSION}\",
          \"body\": \"## Release ${VERSION}\\n\\nSee CHANGELOG.md for details.\",
          \"draft\": false,
          \"prerelease\": false
        }")

      UPLOAD_URL=$(echo "${RELEASE_RESPONSE}" | jq -r '.upload_url' | sed 's/{.*}//')
      RELEASE_ID=$(echo "${RELEASE_RESPONSE}" | jq -r '.id')

      if [ "${RELEASE_ID}" = "null" ] || [ -z "${RELEASE_ID}" ]; then
        echo "Failed to create GitHub release:"
        echo "${RELEASE_RESPONSE}"

        # Try to get existing release
        echo "Attempting to get existing release..."
        RELEASE_RESPONSE=$(curl -s \
          -H "Authorization: token ${GITHUB_TOKEN}" \
          -H "Accept: application/vnd.github.v3+json" \
          "https://api.github.com/repos/${GITHUB_REPO}/releases/tags/${VERSION}")

        UPLOAD_URL=$(echo "${RELEASE_RESPONSE}" | jq -r '.upload_url' | sed 's/{.*}//')
        RELEASE_ID=$(echo "${RELEASE_RESPONSE}" | jq -r '.id')

        if [ "${RELEASE_ID}" = "null" ] || [ -z "${RELEASE_ID}" ]; then
          echo "Could not find or create release"
          exit 1
        fi
      fi

      echo "Uploading binary to release ${RELEASE_ID}..."

      curl -s -X POST \
        -H "Authorization: token ${GITHUB_TOKEN}" \
        -H "Content-Type: application/octet-stream" \
        "${UPLOAD_URL}?name=${BINARY_NAME}-linux-amd64" \
        --data-binary "@target/release/${BINARY_NAME}"

      echo "GitHub release created successfully!"
  rules:
    - if: $CI_COMMIT_TAG
      when: manual
      allow_failure: true
